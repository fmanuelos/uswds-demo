# Cursor Development Guidelines for Next.js Best Practices

**Preamble:**
These instructions guide Cursor AI (and serve as a reference for developers) to generate code adhering to modern best practices for our Next.js project. The goal is high-quality, maintainable, performant, type-safe, secure, and accessible code. When in doubt, prioritize clarity, security, performance, and accessibility. Ask for clarification if instructions seem ambiguous or conflicting.

## Guiding Philosophy

Our primary goal is to build a robust, maintainable, secure, performant, and accessible application by leveraging the strengths of the Next.js App Router and a carefully chosen, type-safe tech stack. Consistency and adherence to these guidelines are key to achieving this.

## How to Use These Instructions

This document serves as the authoritative guide for developing our Next.js application. Cursor AI and developers should:

1.  **Understand the Philosophy & Principles:** Grasp the overarching goals and foundational priorities before starting any task.
2.  **Consult Core Technologies:** Know which libraries/frameworks are approved and their roles.
3.  **Follow Specific Guidelines:** Adhere strictly to the practices outlined for each technology (Next.js, React, TanStack Query, etc.).
4.  **Prioritize Specific Instructions:** When generating code for Forms, State Management (Server/Client), or UI, prioritize the detailed instructions provided in the dedicated sections (`react-hook-form`, TanStack Query, Zustand, Tailwind/Shadcn UI).
5.  **Ask for Clarification:** If any instruction is unclear, contradictory, or a new scenario arises not covered here, prompt for clarification.
6.  **Review Against Principles:** Before finalizing code, mentally (or explicitly) check if it aligns with Core Principles (App Router, RSCs default, Security, Performance, A11y, Consistency).
7.  **Leverage for Prompts:** When prompting Cursor AI, refer to relevant sections or principles from this document to ensure generated code aligns with these standards. For example: "Create a Next.js API route handler for `POST /api/items`. Ensure Zod validation for the request body as per `lib/validation/item-schema.ts`, NextAuth.js authentication, and structured error handling as outlined in our guidelines."
8.  **Iterate and Refine:** Always review and critically assess code generated by Cursor AI against these guidelines. Be prepared to iterate and refine the suggestions to ensure they meet project standards.

## Core Principles (Priorities):

1.  **App Router First:** Always use the Next.js App Router (`/app`).
2.  **Server Components by Default:** Prioritize RSCs for initial data fetching and reducing client JS, thereby improving initial page load performance. Use Client Components (`"use client"`) only for interactivity, hooks, and browser APIs.
3.  **TanStack Query for Server State:** Use **TanStack Query** for managing asynchronous server state (fetching, caching, updating) in Client Components.
4.  **Zustand for Global Client State:** Use **Zustand** for **non-server related** global state (UI state, theme, etc.) strictly in Client Components. Avoid for server-fetched data or form state.
5.  **`react-hook-form` for Forms:** Use **`react-hook-form`** integrated with **Zod** for all form management (state, validation, submission) in Client Components.
6.  **Strict TypeScript:** Enforce strict mode. Ensure accurate, explicit types, leveraging type inference where appropriate but prioritizing clarity.
7.  **Custom UI + Tailwind CSS:** Build UI using **custom components** in `components/ui/` styled with **Tailwind CSS** and following USWDS design guidelines. Ensure Accessibility (`a11y`).
8.  **NextAuth.js + Prisma for Auth/DB:** Use **NextAuth.js (v5+)** + Prisma adapter + **PostgreSQL**.
9.  **Security & Performance:** Embed these considerations throughout development, not as afterthoughts.
10. **Accessibility (a11y):** Ensure all UI and flows are accessible as a primary requirement.
11. **Consistency:** Strive for code that looks and feels uniform across the project, as if written by a single developer. Adhere to established patterns and conventions.

## Core Technologies:

* **Next.js:** Version 14+ (or latest stable). App Router mandatory.
    * **Server Actions:** While Next.js Server Actions exist for mutations, this project standardizes on TanStack Query (`useMutation`) for managing asynchronous server state modifications initiated from Client Components. This approach ensures consistency in caching, retries, optimistic updates, and overall server state management. Server Actions may be considered for very simple, purely server-side mutations within Server Components if they don't interact with client-side state managed by TanStack Query.
* **TypeScript:** Strict mode enabled. Explicit types. **Default to using `type`** for defining object shapes, unions, intersections, function signatures, and leveraging utility types. Use `interface` primarily when its specific features like declaration merging are required. Use `satisfies` where beneficial. Prefer `unknown` over `any` for genuinely unknown input/output types, implementing necessary type guards or assertions for safe usage.
* **React:** Version 18+ (or latest stable). Functional components with hooks only. Utilize Suspense and Error Boundaries. Avoid default exports for components and pages.
* **State Management:**
    * **Server State:** **TanStack Query (`@tanstack/react-query`)**.
    * **Global Client State:** **Zustand**. *Avoid using React Context for global state that changes frequently; prefer Zustand.*
    * **Form State:** **`react-hook-form`**.
    * **Local Component State:** React Hooks (`useState`, `useReducer`).
* **Forms:**
    * **`react-hook-form`**: Primary library for form handling.
    * **`@hookform/resolvers`**: For integrating validation schemas (specifically Zod).
* **UI/UX Frameworks:**
    * **Tailwind CSS:** Version 3.x. Utility-first.
    * **Custom UI Components:** Primary component library in `components/ui/` following USWDS design system.
    * **Radix UI:** Optional primitives for complex headless components requiring maximum accessibility control.
* **Validation:**
    * **Zod:** Primary library for schema definition and validation. Use with `react-hook-form` via `@hookform/resolvers/zod` and for **server-side API validation**.
* **Authentication:**
    * **NextAuth.js:** Version 5+ (or latest stable). Use **Credentials provider** and any other **specified project providers**.
* **Database:**
    * **PostgreSQL:** Primary database.
    * **Prisma:** ORM. Use latest stable version.
* **Testing:**
    * **Vitest:** Unit/Integration tests.
    * **React Testing Library:** Component testing for Client Components.
    * **Playwright:** For end-to-end testing of critical user flows.
    * **`next-test-api-route-handler`**: For testing API Route Handlers (or suitable alternative if adopted, e.g., MSW for intercepting requests).
* **Package Manager:** Use **`pnpm`** (or the designated project package manager - `yarn`/`npm`) consistently for all dependency management. Ensure the lock file (`pnpm-lock.yaml`) is committed and only one package manager is used.

## General Best Practices:

* **Project File Structure:** Adhere to the structure below. Colocate files related to a feature where it makes sense, but respect the `app/` router and `components/ui` conventions. Consider private folders (e.g., `_components`, `_lib`) within route segments for segment-specific, non-route files if they don't fit into the broader `lib` or `components` structure.
    ```
    my-app/
    ├── app/
    │   ├── (routes)/...             # Route segments (e.g., (dashboard), (marketing), /auth)
    │   │   ├── _components/         # Optional: Private components for this route segment
    │   ├── api/
    │   │   └── auth/[...nextauth]/route.ts # NextAuth catch-all
    │   │   └── (feature)/[action]/route.ts # Feature-specific API routes
    │   ├── layout.tsx               # Root layout (RSC) - includes providers
    │   ├── page.tsx                 # Root page (RSC)
    │   └── lib/
    │       ├── auth.ts              # NextAuth configuration
    │       ├── constants.ts         # Project-wide constants
    │       ├── db/
    │       │   ├── schema.prisma    # Prisma schema
    │       │   └── client.ts        # Prisma client instance (singleton)
    │       ├── query/
    │       │   ├── provider.tsx     # TanStack Query Provider (Client Component)
    │       │   ├── client.ts        # TanStack Query client instance
    │       │   └── keys.ts          # Query key factories
    │       ├── store/               # Zustand stores
    │       │   └── use-[feature]-store.ts
    │       ├── validation/          # Zod schemas
    │       │   └── [schema-name].ts
    │       └── utils.ts             # General utilities, cn function
    ├── components/
    │   ├── auth/                    # Auth-specific components
    │   ├── ui/                      # Custom UI components (USWDS-based)
    │   ├── layout/                  # Layout-specific components
    │   └── features/                # Feature-specific components
    ├── prisma/
    │   └── migrations/
    ├── public/                      # Static assets
    ├── styles/
    │   └── globals.css              # Tailwind directives and global styles
    ├── tests/                       # E2E tests (Playwright), integration tests setup
    ├── .env.local                   # Local environment variables (DO NOT COMMIT)
    ├── .env.example                 # Template for environment variables
    ├── pnpm-lock.yaml               # Lock file
    ├── tailwind.config.js
    ├── next.config.mjs
    ├── package.json
    ├── tsconfig.json
    ├── prettier.config.js
    └── .eslintrc.json
    ```
* **Naming Conventions:**
    * Components, Types, Interfaces: `PascalCase`
    * Variables, Functions, Hooks: `camelCase`
    * Constants (exported/file-level): `UPPER_SNAKE_CASE`
    * **Component Files and Folders:** For React components, use `PascalCase` for both the folder and the main file within it. Co-locate related files (like tests and stories) in the same component folder.
      * **Example:** The `UserProfile` component should be located at `components/features/UserProfile/UserProfile.tsx`. Its test file would be `components/features/UserProfile/UserProfile.test.tsx`.
    * **Non-Component Files and Folders:** Use `kebab-case` for all other directories and files (e.g., `lib/utils`, `hooks/use-auth-status.ts`).
* **Code Style:** Adhere strictly to Prettier. Use meaningful names. Write JSDoc comments for complex functions, components, types, and all exported members (e.g., using `@param`, `@returns`, `@description`). Follow SOLID and DRY. Prioritize readability. Enforce with ESLint/Prettier via pre-commit hooks.
* **Avoid Magic Values:** Define in `lib/constants.ts` or locally as `const`.
* **Environment Variables:** Use `.env.local` (uncommitted) and `.env.example`. Prefix browser-exposed variables with `NEXT_PUBLIC_`. Securely manage production secrets.
* **Dependency Management:** Regularly review and update dependencies using `pnpm up --latest` (or equivalent). Address breaking changes systematically, ensuring thorough testing before merging.

## Specific Guidelines:

* **TypeScript:** (Covered in Core Technologies - explicit `type` usage, `satisfies`, Zod/Prisma type inference, `as const`, strong typing for TanStack Query, `unknown` over `any`).
* **React:** Minimize Client Components. Pass serializable data from RSCs. Use `react-hook-form` for forms. Use TanStack Query for server state. Avoid prop drilling (use context, Zustand for global client state, or direct props). Immutable updates. Implement Error Boundaries and Suspense. Avoid default exports.
* **Next.js:** Route Handlers for APIs. Fetch initial data in RSCs. Protect routes/APIs with `auth()` from `next-auth`. Use `middleware.ts` for path-based redirects, `auth()` for data authorization. Set up `QueryClientProvider`. Implement `loading.tsx` and `error.tsx`.
* **`react-hook-form`:**
    * **Use Case:** Mandatory for all forms in Client Components.
    * **Integration:** Always with Zod (`@hookform/resolvers/zod`).
    * **Schema:** `lib/validation/`, infer type with `z.infer<typeof yourSchema>`.
    * **Setup:** `useForm<YourFormType>({ resolver: zodResolver(yourSchema), defaultValues: {...} });`.
    * **Custom UI Integration:** Use custom Form components from `components/ui/` for structure, a11y, and error display.
    * **Submission:** `async function onSubmit(values: YourFormType) { ... }`, pass to `form.handleSubmit(onSubmit)`.
    * **Submission State:** Use `form.formState.isSubmitting`.
    * **Server Errors:** In `onSubmit`, handle API errors from TanStack `useMutation`. Use `form.setError("root", ...)` or `form.setError("fieldName", ...)`.
* **Validation (Zod):** Define schemas in `lib/validation`. **CRITICAL:** Use these schemas with `react-hook-form` (client) AND for validating incoming request bodies/parameters in API Route Handlers (server) **at the beginning** of the handler.
* **TanStack Query:** Manage server state in Client Components (`useQuery`, `useMutation`). Consistent query keys (`lib/query/keys.ts`). Leverage `initialData` from RSCs. Invalidate/refetch post-mutation. Handle loading/error/data states. Consider `staleTime` and `gcTime`. Strongly type hooks.
* **Zustand:** **Only** for global client UI state (modal visibility, theme, etc.). **NOT** for server data or form state. Define in `lib/store/`. Immutable updates. Explicit TS types. Use selectors. **Mind hydration issues:** access browser APIs (`window`, `localStorage`) only in effects or after `typeof window !== 'undefined'`.
* **Tailwind/Custom UI:** Prioritize `components/ui/` custom components. Styles via `className`. Customize with props and `className` overrides using `cn` utility. Follow USWDS design guidelines. Responsive modifiers (`sm:`, `md:`). **Ensure Accessibility:** keyboard navigation, focus states, ARIA, color contrast.
* **API Routes (Route Handlers):** RESTful design. **Mandatory:** Validate ALL incoming data with Zod schemas (`lib/validation`) **at the beginning** of the handler. Proper error handling (HTTP status codes, structured JSON). Rate limiting. Structured server-side logging.
* **NextAuth.js:** Secure `NEXTAUTH_SECRET`. Implement providers. Prisma adapter. `jwt`, `session` callbacks. Graceful auth errors. Use `auth()` for server-side session status.
* **Prisma/PostgreSQL:** Schema in `prisma/schema.prisma`. Use Prisma Client (`lib/db/client.ts` - **singleton pattern crucial**). `prisma migrate dev`. Transactions for atomicity. Optimize queries (select, include); be mindful of N+1 issues and use `include` or batched queries appropriately. Handle DB errors.
* **Security:** **Validate ALL input server-side (Zod)**. Sanitize user output if rendered directly as HTML (prefer React's default text rendering). Implement authorization with `auth()`. Hash passwords (NextAuth handles this). Keep dependencies updated. Rate limiting. CORS if needed. HTTPS in production. Avoid exposing secrets client-side.
* **Performance:** Minimize client JS with RSCs. Code split (`next/dynamic` with `ssr: false`). `next/image`. Next.js caching. TanStack Query caching. `React.memo`, `useMemo`, `useCallback` *judiciously* (profile first). Zustand selectors. Analyze bundle size. Optimize DB queries.
* **Custom UI Components (`components/ui/`):** 
    * Follow USWDS design system principles and color palette.
    * Use `class-variance-authority` (cva) for variant management.
    * Implement proper TypeScript interfaces extending appropriate HTML element types.
    * Include comprehensive Storybook stories for documentation and testing.
    * Ensure all components support `className` override via `cn` utility.
    * Implement proper accessibility attributes and keyboard navigation.
    * Use `React.forwardRef` for ref forwarding when appropriate.
    * Follow consistent naming: `Button`, `Separator`, `Input`, etc.
* **Accessibility (a11y):** Core principle. Keyboard navigable, clear focus. Semantic HTML. ARIA (custom UI/Radix help, verify). Color contrast. Test with screen readers. WAI-ARIA practices.

## Error Handling Strategy

Implement a consistent error handling approach:

1.  **Server Components & Route Handlers:** `try...catch`. Log errors server-side. Return meaningful API error responses (4xx/5xx, structured JSON). Avoid leaking sensitive details.
2.  **Client Components (TanStack Query):** Use `isError`, `error`. Display user-friendly messages. Use `error.tsx`.
3.  **Client Components (UI/Logic):** React Error Boundaries (`error.tsx` or custom).
4.  **Forms (`react-hook-form`):** Zod errors via `<FormMessage>`. Catch submission errors in `onSubmit`. `form.setError()`.
5.  **Data Fetching Errors in RSCs:** `try...catch`. Render alternative UI or pass error state.
6.  **Client-Side Notifications:** For general feedback (e.g., successful operations, non-critical errors not tied to a form field), use the project's designated toast notification system (e.g., Sonner, if integrated with Shadcn UI).

## Testing Strategy

Implement a comprehensive testing suite:

1.  **Unit Tests (Vitest):** Isolated logic (utilities, Zod schemas, Zustand stores).
2.  **Component Tests (React Testing Library + Vitest):** Client Components (interaction, rendering, state, a11y). Mock hooks/API calls (e.g., using MSW - Mock Service Worker - to mock API responses for components using TanStack Query, rather than TanStack Query itself, for more integrated tests). Test custom UI components from `components/ui/`. Test forms.
3.  **API Route Handler Tests (Vitest + `next-test-api-route-handler` or MSW):** Test API logic, request simulation, response assertion. **Mandatory:** Test Zod validation and auth/authz. Mock DB or use test DB.
4.  **Integration Tests (Vitest):** Interactions between multiple units.
5.  **End-to-End (E2E) Tests (Playwright):** Critical user flows.
6.  **Mocking:** Use `vitest` mocking (`vi.fn()`, `vi.mock()`).
7.  **Test Data:** Realistic data (valid, invalid, edge cases).
8.  **Colocation:** Test files adjacent to code (`Component.test.tsx`).

## Code Splitting & Lazy Loading

Improve initial load performance:

* Use `next/dynamic` with `ssr: false` to dynamically import Client Components not essential for initial render or shown based on interaction (e.g., modals, complex UI below fold).

## Developer Experience (DevEx)

* **Storybook:** If using Storybook for component development and documentation, create stories for UI components, showcasing different states and props.
* **Commit Message Conventions:** Adhere to Conventional Commits format (e.g., `feat: add user login page`, `fix: resolve issue with form validation`).
* **Branching Strategy:** Follow a consistent branching model (e.g., Gitflow-like with feature branches: `feature/`, `fix/`, `chore/`).
* **Logging (Client-Side):** For client-side error tracking or analytics, use the designated project tool (e.g., Sentry, LogRocket), if specified.

## Internationalization (i18n)

* If the application requires multi-language support, refer to the project's specific i18n guidelines (e.g., using a library like `next-intl`, structure of translation files, key naming conventions). If not yet implemented but planned, consult with the team lead.